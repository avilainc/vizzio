use crate::core::Binary;
use crate::analysis::BinaryAnalyzer;
use super::{SignatureDatabase, HeuristicEngine};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct MalwareDetectionResult {
    pub is_malicious: bool,
    pub confidence: f64,
    pub detections: Vec<Detection>,
    pub family: Option<String>,
    pub behavior_tags: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Detection {
    pub detection_type: DetectionType,
    pub name: String,
    pub description: String,
    pub confidence: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum DetectionType {
    Signature,
    Heuristic,
    Behavioral,
    Yara,
}

pub struct MalwareDetector {
    signature_db: SignatureDatabase,
    heuristic_engine: HeuristicEngine,
}

impl MalwareDetector {
    pub fn new() -> Self {
        Self {
            signature_db: SignatureDatabase::new(),
            heuristic_engine: HeuristicEngine::new(),
        }
    }

    pub fn detect(&self, binary: &Binary) -> MalwareDetectionResult {
        let mut detections = Vec::new();

        // Verificação por assinatura
        let sig_matches = self.signature_db.scan(&binary.data);
        for sig_match in sig_matches {
            detections.push(Detection {
                detection_type: DetectionType::Signature,
                name: sig_match.name,
                description: sig_match.description,
                confidence: 0.95,
            });
        }

        // Análise heurística
        let heuristic_results = self.heuristic_engine.analyze(binary);
        for result in heuristic_results {
            detections.push(Detection {
                detection_type: DetectionType::Heuristic,
                name: result.rule_name,
                description: result.description,
                confidence: result.confidence,
            });
        }

        // Análise comportamental
        let behavioral_tags = self.analyze_behavior(binary);

        let is_malicious = !detections.is_empty() ||
                          behavioral_tags.iter().any(|t| t.starts_with("malware"));

        let confidence = if detections.is_empty() {
            0.0
        } else {
            detections.iter().map(|d| d.confidence).sum::<f64>() / detections.len() as f64
        };

        let family = Self::identify_family(&detections);

        MalwareDetectionResult {
            is_malicious,
            confidence,
            detections,
            family,
            behavior_tags: behavioral_tags,
        }
    }

    fn analyze_behavior(&self, binary: &Binary) -> Vec<String> {
        let mut tags = Vec::new();

        // Verificar comportamentos suspeitos
        let suspicious_imports: Vec<&str> = vec![
            "CreateRemoteThread", "VirtualAllocEx", "WriteProcessMemory",
            "SetWindowsHookEx", "GetAsyncKeyState", "InternetOpen",
        ];

        for import in &binary.imports {
            if suspicious_imports.iter().any(|&s| import.function.contains(s)) {
                tags.push(format!("suspicious_api:{}", import.function));
            }
        }

        // Verificar características de packer
        let high_entropy_sections = binary.sections.iter()
            .filter(|s| s.entropy > 7.0)
            .count();

        if high_entropy_sections > 0 {
            tags.push("packed".to_string());
        }

        // Verificar anti-debug
        let antidebug_funcs = ["IsDebuggerPresent", "CheckRemoteDebuggerPresent", "OutputDebugString"];
        if binary.imports.iter().any(|i| antidebug_funcs.iter().any(|&f| i.function.contains(f))) {
            tags.push("anti_debug".to_string());
        }

        tags
    }

    fn identify_family(detections: &[Detection]) -> Option<String> {
        // Lógica simples para identificar família de malware
        for detection in detections {
            if detection.name.contains("Trojan") {
                return Some("Trojan".to_string());
            } else if detection.name.contains("Ransomware") {
                return Some("Ransomware".to_string());
            } else if detection.name.contains("Backdoor") {
                return Some("Backdoor".to_string());
            }
        }
        None
    }
}

impl Default for MalwareDetector {
    fn default() -> Self {
        Self::new()
    }
}

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Exploit {
    pub id: String,
    pub name: String,
    pub cve: Option<String>,
    pub description: String,
    pub target_software: String,
    pub exploit_type: ExploitType,
    pub severity: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExploitType {
    RemoteCodeExecution,
    LocalPrivilegeEscalation,
    DenialOfService,
    InformationDisclosure,
    BufferOverflow,
    UseAfterFree,
    Other(String),
}

pub struct ExploitDatabase {
    exploits: HashMap<String, Exploit>,
}

impl ExploitDatabase {
    pub fn new() -> Self {
        let mut db = Self {
            exploits: HashMap::new(),
        };
        db.load_default_exploits();
        db
    }

    fn load_default_exploits(&mut self) {
        // Adicionar alguns exploits conhecidos como exemplo
        self.add_exploit(Exploit {
            id: "EXP001".to_string(),
            name: "EternalBlue".to_string(),
            cve: Some("CVE-2017-0144".to_string()),
            description: "SMBv1 Remote Code Execution".to_string(),
            target_software: "Windows SMB".to_string(),
            exploit_type: ExploitType::RemoteCodeExecution,
            severity: "Critical".to_string(),
        });

        self.add_exploit(Exploit {
            id: "EXP002".to_string(),
            name: "BlueKeep".to_string(),
            cve: Some("CVE-2019-0708".to_string()),
            description: "RDP Remote Code Execution".to_string(),
            target_software: "Windows RDP".to_string(),
            exploit_type: ExploitType::RemoteCodeExecution,
            severity: "Critical".to_string(),
        });
    }

    pub fn add_exploit(&mut self, exploit: Exploit) {
        self.exploits.insert(exploit.id.clone(), exploit);
    }

    pub fn search(&self, query: &str) -> Vec<&Exploit> {
        self.exploits.values()
            .filter(|e| {
                e.name.to_lowercase().contains(&query.to_lowercase()) ||
                e.description.to_lowercase().contains(&query.to_lowercase()) ||
                e.cve.as_ref().map_or(false, |cve| cve.contains(query))
            })
            .collect()
    }

    pub fn get_by_cve(&self, cve: &str) -> Option<&Exploit> {
        self.exploits.values()
            .find(|e| e.cve.as_ref().map_or(false, |c| c == cve))
    }
}

impl Default for ExploitDatabase {
    fn default() -> Self {
        Self::new()
    }
}

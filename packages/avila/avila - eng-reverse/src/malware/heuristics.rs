use crate::core::Binary;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HeuristicResult {
    pub rule_name: String,
    pub description: String,
    pub confidence: f64,
    pub severity: u8,
}

pub struct HeuristicEngine {
    rules: Vec<HeuristicRule>,
}

struct HeuristicRule {
    name: String,
    description: String,
    check_fn: fn(&Binary) -> Option<f64>,
}

impl HeuristicEngine {
    pub fn new() -> Self {
        let mut engine = Self { rules: Vec::new() };
        engine.load_default_rules();
        engine
    }

    fn load_default_rules(&mut self) {
        self.rules.push(HeuristicRule {
            name: "High Entropy Sections".to_string(),
            description: "Detecta seções com alta entropia (possível criptografia/compressão)".to_string(),
            check_fn: |binary| {
                let high_entropy = binary.sections.iter()
                    .filter(|s| s.entropy > 7.5)
                    .count();
                if high_entropy > 0 {
                    Some(0.7 + (high_entropy as f64 * 0.1).min(0.25))
                } else {
                    None
                }
            },
        });

        self.rules.push(HeuristicRule {
            name: "Suspicious API Calls".to_string(),
            description: "Detecta uso de APIs perigosas".to_string(),
            check_fn: |binary| {
                let dangerous_apis = [
                    "VirtualAlloc", "VirtualProtect", "CreateRemoteThread",
                    "WriteProcessMemory", "SetWindowsHookEx", "NtSetInformationThread",
                ];

                let count = binary.imports.iter()
                    .filter(|imp| dangerous_apis.iter().any(|&api| imp.function.contains(api)))
                    .count();

                if count >= 3 {
                    Some(0.6 + (count as f64 * 0.1).min(0.35))
                } else {
                    None
                }
            },
        });

        self.rules.push(HeuristicRule {
            name: "Executable in Unusual Section".to_string(),
            description: "Código executável em seção não convencional".to_string(),
            check_fn: |binary| {
                let unusual = binary.sections.iter()
                    .any(|s| {
                        let is_exec = (s.characteristics & 0x20000000) != 0;
                        let is_writable = (s.characteristics & 0x80000000) != 0;
                        is_exec && is_writable && !s.name.contains("text")
                    });

                if unusual {
                    Some(0.8)
                } else {
                    None
                }
            },
        });

        self.rules.push(HeuristicRule {
            name: "No Imports".to_string(),
            description: "Binário sem imports (possível shellcode ou loader customizado)".to_string(),
            check_fn: |binary| {
                if binary.imports.is_empty() && binary.data.len() > 1024 {
                    Some(0.75)
                } else {
                    None
                }
            },
        });

        self.rules.push(HeuristicRule {
            name: "Abnormal Entry Point".to_string(),
            description: "Entry point fora das seções de código".to_string(),
            check_fn: |binary| {
                let in_code_section = binary.sections.iter()
                    .any(|s| {
                        let is_code = s.name.contains("text") || s.name.contains("code");
                        let contains_ep = binary.entry_point >= s.virtual_address &&
                                        binary.entry_point < s.virtual_address + s.virtual_size;
                        is_code && contains_ep
                    });

                if !in_code_section && binary.entry_point != 0 {
                    Some(0.85)
                } else {
                    None
                }
            },
        });

        self.rules.push(HeuristicRule {
            name: "TLS Callbacks".to_string(),
            description: "Uso de TLS callbacks para anti-debugging".to_string(),
            check_fn: |binary| {
                // Verificação simplificada
                if binary.data.len() > 100 {
                    // Procurar padrão de TLS callbacks em PE
                    for i in 0..binary.data.len().saturating_sub(20) {
                        if binary.data[i..i+4] == [0x54, 0x4C, 0x53, 0x00] { // "TLS\0"
                            return Some(0.65);
                        }
                    }
                }
                None
            },
        });

        self.rules.push(HeuristicRule {
            name: "Code Injection Indicators".to_string(),
            description: "Padrão de injeção de código".to_string(),
            check_fn: |binary| {
                let injection_apis = [
                    "CreateRemoteThread", "QueueUserAPC", "SetThreadContext",
                    "NtQueueApcThread", "RtlCreateUserThread",
                ];

                let has_injection = binary.imports.iter()
                    .any(|imp| injection_apis.iter().any(|&api| imp.function.contains(api)));

                if has_injection {
                    Some(0.9)
                } else {
                    None
                }
            },
        });
    }

    pub fn analyze(&self, binary: &Binary) -> Vec<HeuristicResult> {
        let mut results = Vec::new();

        for rule in &self.rules {
            if let Some(confidence) = (rule.check_fn)(binary) {
                results.push(HeuristicResult {
                    rule_name: rule.name.clone(),
                    description: rule.description.clone(),
                    confidence,
                    severity: Self::calculate_severity(confidence),
                });
            }
        }

        results
    }

    fn calculate_severity(confidence: f64) -> u8 {
        if confidence >= 0.9 {
            4 // Critical
        } else if confidence >= 0.75 {
            3 // High
        } else if confidence >= 0.5 {
            2 // Medium
        } else {
            1 // Low
        }
    }

    pub fn add_rule(&mut self, rule: HeuristicRule) {
        self.rules.push(rule);
    }
}

impl Default for HeuristicEngine {
    fn default() -> Self {
        Self::new()
    }
}
